# Thread

> 프로세스에서 내에서 실행되는 흐름의 단위
>
> 하나의 역할이 하나의 쓰레드가 된다.
>
> 한 번 종료된 쓰레드는 다시 실행할 수 없다. (재시작 해야 함)
>
> ex) 게임하면서 채팅, 음악 들으면서 문서작업 후 인쇄

---

* 스케줄링 필요

  : 같은 프로세스 내 공유 데이터에 여러 스레드들이 접근할 수 있다.

  단, 어떤 스레드가 먼저 작업할지 스케줄링을 해주어야 한다.

  [**멀티 스레드**]

  ```markdown
  - 하나의 프로그램을 띄워놓고 동시에 여러 실행 흐름을 만들어 작업할 수 있게 해주는 방식
  - CPU의 코어 하나가 하나의 작업만 수행할 수 있기 때문에 코어 수가 작업할 수 있는 작업의 수라고 볼 수 있다.
  
  => 웹은 웹서버가 이 작업을 해주었기 때문에 상관없었지만 앱은 따로 처리해주어야 함.
  ```

  [**프로세스**]

  > 실행중인 프로그램
  >
  > 대부분의 OS는 멀티태스킹(다중 작업)을 지원하기 때문에 여러 프로세스가 동시에 진행될 수 있다.

## Runnable

> Thread클래스를 직접 상속받으면 확장성이 줄기 때문에 Runnable 인터페이스를 implements하는 방식이 추천된다.

```java
public class Thread {
    Runnable target;
    public Thread(Runnable target) {
        this.target = target;
    }
    
    public void start() {
        //현재 쓰레드의 run() 호출
    }
    
    public void run() {
        //생성자에서 받은 Runnable객체의 run() 호출
    }
}
```

## Synchronizing

> 동기화 
>
> 공유데이터에 대한 이슈를 처리하기 위해 실행

* 과정
  * 한 쓰레드가 공유데이터에 접근해 작업할 때 다른 객체가 접근할 수 없도록 **lock**을 걸어야 한다.

```java
public synchronized 리턴타입 메서드명() {
	//동기화 처리할 내용
}
synchronized(공유객체) {
    //동기화 처리할 내용
}
```

> 메서드 자체가 방해를 받으면 안 되는 경우 메서드에,
>
> 일부 코드 부분이 방해를 받으면 안 되는 경우에 코드 블럭으로 
>
> **synchronized**를 처리한다.